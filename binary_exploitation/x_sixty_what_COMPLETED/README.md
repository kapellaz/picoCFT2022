Description
Overflow x64 code
Most problems before this are 32-bit x86. Now we'll consider 64-bit x86 which is a little different! Overflow the buffer and change the return address to the flag function in this program.


flag: picoCTF{b1663r_15_b3773r_964d9987}


For this one I use very new tools for me.
To start, I use gef gdb and create a pattern long enough to break the program
Then we use pattern offset $rsp to get the offset to the value on the $rsp (stack pointer) when the program broke
After that I use readelf to see the binary of the flag() function
Then I modify the script I use on buffer_overflow1 by setting the payload to A*offset + 6** bytes and see the program broke to the where we want.
So what's left now is replace those 6bytes with the ones we got on readelf.
When I run it the program did not succeed, because the remote machine and my local machine were different. To fix that I use "$ disas flag" to see the assembler code of the function flag() and try every instruction binary until one works, whitch in my case was the 2nd one.
 


**we use 6 bytes because in x64 addresses dont use 64bits/8bytes os space, they only use 48 bits/6bytes (thats called canonical address)
